  [1m[35m (17.3ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.9ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.9ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.9ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreateCourses (20170122172219)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (11.0ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (1.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172219"]]
  [1m[35m (51.9ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateChapters (20170122172344)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172344"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePages (20170122172554)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172554"]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePageVisits (20170122172641)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (4.1ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.1ms)[0m  [1m[31mROLLBACK[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreatePageVisits (20170122172641)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (7.0ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.1ms)[0m  [1m[31mROLLBACK[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.7ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreateUsers (20170122172732)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (7.1ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172732"]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateEnrollments (20170122172805)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (5.4ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
, CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
)[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments"  ("course_id")[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments"  ("user_id")[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172805"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePageVisits (20170122172941)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.6ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits"  ("user_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits"  ("page_id")[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172941"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.9ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 17:29:48 UTC], ["updated_at", 2017-01-22 17:29:48 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.9ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.7ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.6ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:49:47 UTC], ["updated_at", 2017-01-22 18:49:47 UTC]]
  [1m[35m (1.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:49:47 UTC], ["updated_at", 2017-01-22 18:49:47 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.4ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "3,4,5,6,7,8,9,10,11"], ["created_at", 2017-01-22 18:50:07 UTC], ["updated_at", 2017-01-22 18:50:07 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.9ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "12,13,14,15,16,17,18,19,20"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.4ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "21,22,23,24,25,26"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "27,28,29,30"], ["created_at", 2017-01-22 18:50:57 UTC], ["updated_at", 2017-01-22 18:50:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mChapter Load (1.3ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters"[0m
  [1m[36mChapter Load (1.5ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters"[0m
  [1m[36mPage Load (5.4ms)[0m  [1m[34mSELECT "pages".* FROM "pages"[0m
  [1m[36mChapter Load (0.2ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" ORDER BY "chapters"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mChapter Load (0.3ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" ORDER BY "chapters"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mChapter Load (3.5ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" ORDER BY "chapters"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mPage Load (0.5ms)[0m  [1m[34mSELECT "pages".* FROM "pages" WHERE "pages"."id" IN (3, 4, 5, 6, 7, 8, 9, 10, 11)[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.3ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (5040.7ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.9ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "31,32,33,34,35,36,37,38,39"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:55:44 UTC], ["updated_at", 2017-01-22 18:55:44 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "40,41,42,43,44,45"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "46,47,48,49"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "50,51,52,53"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "54,55,56,57"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "58,59,60,61"], ["created_at", 2017-01-22 18:55:45 UTC], ["updated_at", 2017-01-22 18:55:45 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (5042.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (8.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (1.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.6ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "62,63,64,65,66,67,68,69,70"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "71,72,73,74,75,76"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "77,78,79,80"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "81,82,83,84"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "85,86,87,88"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "89,90,91,92"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "file_path", "chapter_ids", "last_commit", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["file_path", "ios"], ["chapter_ids", "11,12,13,14,15,16"], ["last_commit", "3aabdba706bc325715ae85fffed57ddb08a18926"], ["created_at", 2017-01-22 18:56:22 UTC], ["updated_at", 2017-01-22 18:56:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (132.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (127.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (486.8ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (491.0ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (2.1ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (19.1ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (1.3ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.9ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (1.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (15.3ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (3.1ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (5.2ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.8ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.0ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.6ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.1ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.6ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.9ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.7ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "1,2,3,4,5,6,7,8,9"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "10,11,12,13,14,15"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "16,17,18,19"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "20,21,22,23"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (13.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.6ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (2.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.9ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "24,25,26,27"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "28,29,30,31"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.2ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "file_path", "chapter_ids", "last_commit", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["file_path", "ios"], ["chapter_ids", "1,2,3,4,5,6"], ["last_commit", "3aabdba706bc325715ae85fffed57ddb08a18926"], ["created_at", 2017-01-22 18:56:37 UTC], ["updated_at", 2017-01-22 18:56:37 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.3ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.3ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (120.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (117.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (479.9ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (480.3ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (2.1ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (18.5ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.1ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (4.3ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.1ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (1.7ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (35.1ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.0ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (1.2ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.6ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.1ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.7ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.8ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (1.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.9ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "1,2,3,4,5,6,7,8,9"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "10,11,12,13,14,15"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "16,17,18,19"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "20,21,22,23"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "24,25,26,27"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "28,29,30,31"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "file_path", "chapter_ids", "last_commit", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["file_path", "ios"], ["chapter_ids", "1,2,3,4,5,6"], ["last_commit", "3aabdba706bc325715ae85fffed57ddb08a18926"], ["created_at", 2017-01-22 18:57:13 UTC], ["updated_at", 2017-01-22 18:57:13 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (120.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (119.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (498.1ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (488.6ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (1.6ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (19.3ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.2ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.0ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (3.0ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.8ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:57:50 UTC], ["updated_at", 2017-01-22 18:57:50 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.1ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (1.3ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (15.7ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.4ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (3.4ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (4.4ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.1ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.2ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:57:50 UTC], ["updated_at", 2017-01-22 18:57:50 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.0ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.7ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (1.5ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.7ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "1,2,3,4,5,6,7,8,9"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:57:56 UTC], ["updated_at", 2017-01-22 18:57:56 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "10,11,12,13,14,15"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "16,17,18,19"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "20,21,22,23"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "24,25,26,27"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "28,29,30,31"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "file_path", "chapter_ids", "last_commit", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["file_path", "ios"], ["chapter_ids", "1,2,3,4,5,6"], ["last_commit", "3aabdba706bc325715ae85fffed57ddb08a18926"], ["created_at", 2017-01-22 18:57:57 UTC], ["updated_at", 2017-01-22 18:57:57 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.3ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (119.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (119.3ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (493.2ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (496.4ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (1.6ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (16.8ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.3ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.4ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.9ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.7ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:58:27 UTC], ["updated_at", 2017-01-22 18:58:27 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (1.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (16.0ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.5ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.6ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.7ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 18:58:27 UTC], ["updated_at", 2017-01-22 18:58:27 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."file_path" = $1 LIMIT $2[0m  [["file_path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.6ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Structs in Swift\n\nStructs in Swift are used to create types that hold a collection of values. **At first ****glance Structs may look very similar to classes but there are a couple key differences that we'll be going over in the coming chapters.**\n\nStructs, like classes, are used to create types. Generally, Structs are used more for creating collections of values. For example representing shapes is a great use for structs! Let's see this in action:\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n}\nvar myRectangle = Rectangle()           // Taking advantage of type inference\nprint(\"\\(myRectangle.width)\")\n```\n\nHere we declare the Rectangle struct that has two stored properties: width and height that each has default values of 10 and 20 respectively. We instantiate the rectangle using the same syntax as with Classes.\n\n### Struct Methods\n\nMethods in Structs are very similar to methods in classes. Let's revisit our rectangle example.\n\n```swift\nstruct Rectangle {\n  var width = 10\n  var height = 20\n  func printDesc() {\n    print(\"I have a width of \\(width) and a height of \\(height)\")\n  }\n  mutating func doubleWidth() {                // Why do we need the mutating keyword here?\n    width *= 2\n  }\n}\n```\n\nWe implemented two methods in Rectangle. The first method, printDesc does not have to be prefixed **with the mutating keyword because the method is not changing the value of the instance in any way**. However, our second method, doubleWidth, **changes the value of one of its properties. Since the value is changing we have to prefix the method with the mutating keyword. **\n\n**Interestingly enough, we do NOT need the mutating keyword when writing a similar method in a Class. This has to do with _value types vs reference types_ which we will go over soon.**\n\n### **Struct Initialization**\n\nSimilar to Classes, with Structs, we need to initialize our properties when instantiating the class if they are not given default values. Fortunately, **Swift will give us a \"memberwise\" initializer so that we don't have to explicitly define the initialization method**. This **memberwise initializer will include external parameter names for all of the stored properties that need values**. Let's see this in action.\n\n```swift\nstruct Rectangle {\n    var width = 200\n    var height = 400\n}\nlet rectangle = Rectangle()\n```\n\nIn the above implementation of the Rectangle Struct, we used the free \"empty\" initializer provided to us by the Swift compiler. We are given a  **f****ree \"empty\" initializer for our Types if we give all of our stored properties default values** **and do not define our own custom initializer.**\n\n```swift\nstruct Rectangle {\n    var width: Int             // If we don't give default vals to vars, we have to use type annotation.\n    var height: Int\n}\n```\n\nIf we don't set the default values for all of the stored properties, then we will have to rely on the **\"memberwise\" initializer mentioned above.** **In this case, we don't have access to the free \"empty\" initializers anymore because we no longer can ensure that every property is going to have a value by the end of the initialization.**\n\n![](http://i.imgur.com/tm9xMnN.png)\n\nWait a minute...the error is saying that we are missing an external parameter name...but we never defined any. Here, because we didn't provide default values for our stored properties, and we didn't implement our own custom initializer,  **Swift will give us a \"memberwise\" initializer this time**.  To reiterate, the **m****emberwise initializer will include external parameter names for all of the stored properties that need values**. \n\n```swift\nstruct Rectangle {\n    var width: Int\n    var height: Int\n}\nlet rectangle = Rectangle(width: 200, height: 400)\n```\n\nIt is important to remember that the  **primary role of initialization is to make sure that the new instance has values for all of its stored properties**. If this is not possible, Swift will yell at us until we make the necessary changes to ensure that all stored properties will have a value at the end.\n\n### But wait... What's the real difference between Classes and Structs? Why do we have both?\n\nTo really understand why we have both Classes and Structs we must understand the difference between value and reference types. Turn to the next chapter to explore this."], ["file_path", "structs"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (1.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Deck of Cards\n\n### Objective\n\nIn Swift Structs and Classes are used extensively. This assignment is designed to help you understand the differences between Classes and Structs so that you can choose the best construct for your needs when building your own applications. It is natural to question whether to use a Class or a Struct, and this will become more and more clear as you use both and see the differences.\n\n### To Do\n\n**Create a struct called \"Card\"**\n\n1.  Give the Card struct a property \"value\" which will hold the value of the card (A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K). This value should be a String\n2.  Give the Card a property \"Suit\" which will hold the suit of the card (Clubs, Spades, Hearts, Diamonds)\n3.  Give the Card a property \"numerical_value\" which will hold the numerical value of the card 1-13\n\n**Next, create a class called \"Deck\"**\n\n1.  Give the Deck class a property called \"cards\" of type [Card]\n2.  When initializing the deck make sure that it has the 52 unique cards in its \"cards\" property\n3.  Give the Deck a deal method that selects the \"top-most\" card, removes it, and returns it\n4.  Give the Deck a reset method that resets the cards property to the contain the original 52 cards\n5.  Give the Deck a shuffle method that randomly reorders the deck's cards\n\n**Finally, create a class called \"Player\"**\n\n1.  Give the Player class a name property\n2.  Give the Player a hand property of type [Card]\n3.  Give the Player a draw method of type (Deck) -> Card which draws a card from a deck, adds it to the players hand, and returns it\n    *   Note how we are passing the Deck by reference here since it is a class. \n4.  Give the Player a discard method of type (Card) -> Bool which discards the Card specified and returns True if the Card existed and was successfully removed or False if the Card was not in the player's hand."], ["file_path", "deck_of_cards"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Playground\n\nPlaygrounds were introduced starting from Xcode 6\\. Swift is a **compiled language**. What this means is that Xcode must first compile the entire program into 1s and 0s before it can execute the program. On the other hand, **Ruby and JavaScript are interpreted languages**. The difference is that compiled languages have to be translated completely before running while interpreted languages get translated on the fly as the program is getting read.\n\nInterpreted languages are slower than compiled languages. However, they are great for certain tasks where speed doesn't matter very much. For example, Interpreted languages are great for web applications because the bottleneck is almost never the language and if it is, it is probably because of poorly written code. On the other hand, native applications and games are often built in compiled languages because once they are compiled, it takes less time to execute than a program written with an interpreted language.\n\nCompiled languages are great but sometimes miss the immediate feedback you can get while playing around with Interpreted languages. This proposes a dilemma because playing around with code line by line is essential in learning a new language. However, this is hard to do with compiled languages. Xcode 6 fixed this issue with Swift with the introduction of Playgrounds. A playground does not require you to compile and run a complete project and evaluates Swift code on the fly like an interpreter for an interpreted language would.\n\nGo ahead and let's create our first Playground project. Click on **Get started with a playground** and create a file called _stringconcat_. \n\n![](http://i.imgur.com/f8DJfCE.png)\n\n![](http://i.imgur.com/TwvPJCe.png)\n\nThe playground is split into two sections. On the left, there is the Swift code editor where we can write our code and on the right we have a sidebar that evaluates Swift code. \n\n![](http://i.imgur.com/7ko9Qn6.gif)\n\n```swift\n//: Playground - noun: a place where people can play\n```\n\nOn the first line, we have a comment. Comments will be ignored when programs are executed. They serve more as a reminder or notice for other developers. We can create a comment by prefixing our comment with '//' and the rest of the line will turn into a comment.\n\n```swift\nimport UIKit\n```\n\nThe import UIKit means that we are including all of the **Application Programming Interfaces (APIs)** made available to iOS and Mac developers by the **UIKit framework**. APIs are just **classes and functions written by someone** that we can use. We have to follow certain instructions depending on what API we are using to make our program run. **Utilizing Apple's APIs is a key component in becoming an effective developer**. We will be directed to Apple's documentation throughout the course so that we can practice learning new skills from reading the documentation. Spend no more than 10 minutes perusing through [UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/). \n\n```swift\nvar str = \"Hello, playground\"\n```\n\nWe declare a variable in swift with the keyword var. **A variable should only hold data that is going to change.** If the data is not going to change, we should not be using a variable. Inside the variable _'str_' we are going to assign the value _\"Hello, playground\"._ The quotations mean that we are creating an **instance of the String Type**. Strings are ordered **collections of characters**. We named our variable _str_ but we could have given it any other name.\n\n```swift\nstr += \" you are so cool\"\n```\n\nHere we are adding two instances of the String Type together to create a new instance of String. This is a shorthand way (compound assignment operator) of adding instances of String Type this way:\n\n```swift\nstr = str + \" you are so cool\"\n```\n\nHere's a quick warning on creating instances of Strings. **Creating instances of String Type does not work with single quotes.**\n\n```swift\nvar errorStr = 'single quotes do not work' // don't use single quotes to create instances of String\n```\n\n## print\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2637/handouts/chapter2637_3609_print.gif)\n\nWe can print out our variables using a **print** function which is a function used to print a value to the console followed by a line break. To see the output we can click the small up arrow on the bottom left of the playground. Before we move on further let's read the Basic Operators overview, Terminology, Assignment Operator, Arithmetic Operators, Compound Assignment Operators in [Basic Operators](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60)."], ["file_path", "playground"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Dictionaries\n\nAn _Array Type_ is useful for a collection of ordered instances, but a **Dictionary Type is more suitable for unordered instances**. When we want to look for a definition, or value of a particular word in a dictionary, we look up the word in the dictionary and read its definition. A **Dictionary Type is a collection type that organizes its content by key-value pairs**. A _key_ maps to a value just like a word in a dictionary maps to a definition. \n\n## Initializing a Dictionary\n\n```swift\n// Here we are declaring myDict variable to be of Dictionary Type that will use instances of String as\n// its keys and instances of Int as its values\nvar myDict2: [String: Int]\n```\n\nOnce again, if we just declare a variable or a constant to be of the _Dictionary Type_, **we will get an error when we try to do something with it because we have not initialized it yet.**\n\n```swift\nvar myDict2: [String: Int] = [String: Int]()\n```\n\nOf course, we can use Swift's type inference:\n\n```swift\nvar myDict2 = [String: Int]()\n```\n\nWe can declare, initialize and set the values of the Dictionary in one line:\n\n```swift\n// here we are declaring myDict variable to be of Dictionary Type that will use instances of String as \n// its keys and instances of Int as its values\nvar dictionary = [\n    \"Kobe\": 24,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\n// Note how we are leveraging Swift's type inference here\n```\n\n## Accessing a Dictionary\n\nWe can access _Dictionaries_ just like how we accessed Arrays. **We just have to provide the key in-between brackets**. However unlike Arrays where the keys are instances of _Ints_ and are zero-index based, Dictionary** _keys_ can really be anything** and are not particularly ordered. We can access Kobe's number this way from the previous dictionary that we created:\n\n```swift\ndictionary[\"Kobe\"]\n```\n\nOn the Playground's right pane, it will say that the value is 24 but don't be fooled. **When we access a Dictionary we get back an Optional Type**. This makes sense because there is a chance that a key doesn't exist in the dictionary. For example, the word 'gullible' might not exist in the _Dictionary_, therefore, it makes sense that when you access a _Dictionary_, **Swift will warn us that it might be nil by returning an Optional**. We can see this safety net in action when we try to store the result of the access to a separate variable:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"] \nprint(jerseyNumber) // Optional is not unwrapped\n```\n\nWe can be very bold and just unwrap it:\n\n```swift\nvar jerseyNumber = dictionary[\"Kobe\"]!\nprint(jerseyNumber)\n```\n\nBut it is better practice to use **Optional Binding**:\n\n```swift\nif let jerseyNumber = dictionary[\"Kobe\"] {\n    print(jerseyNumber)\n}\n```\n\n## Modifying a Dictionary\n\nWe can modify a Dictionary in a similar way we did with Arrays.\n\n```swift\nvar dictionary = [\n    \"Kobe\": 8,\n    \"Lebron\": 23,\n    \"Rondo\": 9\n]\nprint(dictionary)\ndictionary[\"Fisher\"] = 2\nprint(dictionary)\ndictionary[\"Kobe\"] = 24\nprint(dictionary)\n```\n\nIf the _key_ exists, we update the value of what is on the right-hand side of the equals sign. If the_ key_ doesn't exist, we add a new _key_ to the dictionary along with the value we provided on the right of the equals sign.\n\n## Removing\n\nWe can remove a _key-value_ pair by accessing the key and giving it the value of _nil_:\n\n```swift\ndictionary[\"Lebron\"] = nil\n```\n\nOr we can send the message _removeValueForKey_.\n\n```swift\nvar lebronsNumber = dictionary.removeValueForKey(\"Lebron\")\nprint(lebronsNumber)\n```\n\nIt is important to note that **this message returns an Optional Type that might contain the value of the key-value pair that was deleted**. Once again it makes sense that this method returns an _Optional Type_ because the key specified by the user might not be present in the dictionary. We can unwrap it with Optional Binding:\n\n```swift\nif let lebronsNumber = dictionary.removeValueForKey(\"Lebron\") {\n    print(lebronsNumber)\n}\n```\n\n## Looping\n\nWe can use the _for-in_ loop to loop through the _keys_ and the values of Dictionaries. \n\n```swift\nfor (key, value) in dictionary {\n    print(\"The key is \\(key) and the value is \\(value)\")\n}\n```\n\nThe (_key, value_) is of the _Tuple type_. Read more about **Tuples** in the Tuples section in  [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID329).\n\n```swift\nfor x in dictionary {\n    print(x)\n}\n```\n\nIf we don't provide the (_key, value_) then Swift will print out a _tuple_ for each _key-value_ pair. Tuples ARE (key, value) pairs."], ["file_path", "dictionaries"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.7ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Functions\n\nA function is a **name that is related to a block of code we can execute**. To execute this code, we invoke it. A function is invoked when we **call its name, pass along the necessary input, and it will give us back some kind of output (most)**. Some functions take no input and some functions have no output. Even though a function doesn't return anything, it can do something inside the block of code that alters a program. For example:\n\n```swift\nfunc sayHello() {\n    print(\"Hello how are you doing today?\")\n}\n```\n\nHere we defined a function with a **func** keyword and declared its name to be _say__Hello_, and specified that this function does not take in any arguments. When this function is invoked, it will print a greeting to the screen but it will not return anything.\n\n```swift\nsayHello()\n```\n\nWe can invoke this function by **calling its name and passing in the necessary input**. In this case, the function requires no input so we won't pass anything in. This function doesn't return anything, but it will have a side effect of printing something to the **Assistant Editor**.\n\n## Function Parameters\n\n<div>We define what kind of input we want by **declaring parameters.** Let's declare a parameter named 'name' that will be of the String Type. Our function will still not return anything but its side effect will be a little bit more personalized. Note that we need to not only **declare a parameter name but also give the parameter a specific type.**</div>\n\n```swift\nfunc sayHello(name: String) {\n    print(\"Hello, \\(name), how are you doing today?\")\n}\n```\n\nWe can invoke this function by calling its name and passing in the correct number of arguments.\n\n```swift\nsayHello(\"Andrew\")\n```\n\nWait, what's the difference between a parameter and an argument? These two words get mixed up a lot in programming. In this example, **'name' is a parameter** while **\"Andrew\" is an argument**. We **define parameters.** We **pass in arguments** into functions.\n\n## Function With Multiple Parameters\n\nIf our function has multiple parameters, we have to invoke it in a different way. Previously, we were able to invoke a function by just passing in the argument if the function had one parameter.\n\n```swift\nfunc printDescription(w: Int) {\n    print(\"My width is \\(w)\")\n}\nprintDescription(10)                  // \"My width is 10\"\n```\n\nIf there is more than one parameter, we have to **provide parameter names for all arguments except for the first one.**\n\n```swift\nfunc printDescription(w: Int, h: Int) {\n    print(\"My width is \\(w) and height is \\(h)\")\n}\nprintDescription(10, h: 20)           // My width is 10 and my height is 20\nprintDescription(10, 20)              // Error: missing argument label 'h:' in call\n```\n\n## Parameter Names\n\nSometimes having an **external parameter name** helps make our functions more expressive. We can give external parameter names so that when we use the function there's a higher chance that we pass in the right arguments:\n\n```swift\n                                      // The two parameters have external names of width and height\n                                      // and internal names of w and h\nfunc printDescription(width w: Int, height h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\n                                      // The func can be invoked by calling its name and passing in\n                                      // right arguments with corresponding external parameter names.\nprintDescription(width: 10, height: 20)\n```\n\nHowever, it is more Swift-like to leave out the external parameter name for the first argument and instead have the function name describe what the first parameter should be. **This convention is used a lot in Swift and is highly recommended in your own code.**\n\n```swift\nfunc printDescriptionWithWidth(w: Int, andHeight h: Int) {\n    print(\"My width is \\(w) and my height is \\(h)\")\n}\nprintDescriptionWithWidth(10, andHeight: 20)\n```\n\n## Constants v. Variables\n\nWhen we pass in an argument to a function, our function **assigns the value to a constant** with the name of the **internal parameter name**. This becomes clear when we try to modify the constant.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(someInt: Int) {\n    someInt = someInt + 1           // This throws an error because we are trying to modify a constant.\n    print(someInt)\n}\n```\n\nIf we want to modify the argument we have to **specify** that we want to store it in a **variable**.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\n```\n\nHowever when we are passing in an argument and modifying it, its changes will not reflect outside of the function call for value types. We will be going over value types vs. reference types in the next chapter. Strings, Arrays, Dictionaries, Bool, and Ints are Value  Types. Classes and functions are reference types. Here's a quick peek at what's coming ahead. When we have a function that changes a value of an Int, its changes will not persist outside of the function:\n\n```swift\nvar myInt = 1\nfunc changeMyInt(var someInt: Int) {\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(myInt)     // => 2\nprint(myInt)           // => 1\n```\n\nIf we want to be able to make changes within a function to a specific instance of a Value type we need **in-out parameters**.\n\n## In-out Parameters\n\nIf we want to modify an argument and we want that change to appear on the outside of the function call, we need in-out parameters. There are two prerequisites to in-out parameters. First, we have to specify that our parameter is an in-out by prefixing the parameter name with _in-out. _Next, when we invoke the function we have to pass in an argument with the '&' sign prefixed to it. Think of the '&' sign as **passing the memory address of the particular constant or variable** so that the function can go directly there and modify it so that the changes will persist outside of the function.\n\n```swift\nvar myInt = 1\nfunc changeMyInt(inout someInt: Int) {         // must specify \"inout\"\n    someInt = someInt + 1\n    print(someInt)\n}\nchangeMyInt(&myInt)                            // must pass in the variable with \"&\" symbol\nprint(myInt)\n```\n\n## Default Parameter Values\n\nIt's good to have default parameter values sometimes. Let's revisit our sayHello function. If we don't know the name of the person that we are greeting we can have a default value to go with. For example, we can just say \"Hey, buddy.\"\n\n```swift\nfunc sayHello(name: String = \"buddy\") {\n    print(\"Hey \\(name)\")\n}\n                 // We can call it without providing any arguments and the default value will be used...\nsayHello()\n                 // ...or we can call it with an argument and that argument's value will be used\nsayHello(\"Yoda\")\n```\n\n## Return\n\nSo far none of our functions had any tangible output. In many cases, we would want our function to return some sort of value that we can use later in our program. Let's modify our _sayHello_ function and observe the differences:\n\n```swift\nfunc sayHello(name: String = \"buddy\") -> String {\n    return \"Hey \\(name)\"\n}\nvar greeting: String?\ngreeting = sayHello()\nprint(greeting)\n```\n\nThis time, we are returning an instance of a String Type from our function. We have to specify in our function declaration that we are going to return an instance of a String Type. This is a **binding contract**, Swift will throw us an error when we construct our code in a way where an instance of a String Type might not return. Let's look at another example.\n\n```swift\nfunc calculateAreaOfRectangleWithWidth(w: Int, andHeight h: Int) -> Int {\n    return w * h\n}\nvar area = calculateAreaOfRectangleWithWidth(10, andHeight: 3)\nprint(area)\n```\n\nHere, our function has two parameters that will both be an instance of Int Type and our function promises to return an instance of an Int Type. If we want to return a value in some cases, we just have to specify that our function will return an Optional Type. For example:\n\n```swift\n// We are declaring a function named lookForSomethingIn and declaring two parameters.\n// The first parameter will be an instance of Dictionary, with keys being instances of String\n// and values being instances of Int.\n// The first parameter has no external name but it has an internal name of dictionary.\n// The second parameter will be an instance of a String.\n// It has an external name of forKey and an internal name of key.\n// This function promises to return an Optional Type that can either be nil or hold an instance of Int.\nfunc lookForSomethingIn(dictionary: [String: Int], forKey key: String) -> Int? {\n    if let value = dictionary[key] {\n        return value\n    } else {\n        return nil\n    }\n}\nvar jerseyNumber = lookForSomethingIn(jerseyNumbers, forKey: \"Kobe\")\nif let num = jerseyNumber {\n    print(num)\n}\n```\n\n## Scope\n\nScope describes the **visibility an instance or a function will have**. Anything within a function's scope will be visible to that function. Every time we type {} we can think of it as creating a new inner scope within the current scope. The inner scopes will have access to the outer scopes while outer scopes do not have access to inner scopes.\n\n![](http://i.imgur.com/iqoGfQq.png)\n\n## Function Types\n\nSo what's a function's type? Let's look at the following function:\n\n```swift\nfunc findMinOf(arr: [Int]) -> Int? {\n    if arr.count > 0 {\n        var min = arr[0]\n        for num in arr {\n            if num < min {\n                min = num\n            }\n        }\n        return min\n    } else {\n        return nil\n    }\n}\n```\n\nThis function takes in one argument of an instance of Array that holds a collection of Ints and returns an Optional Type that **may contain nil or contain a value of an instance of an Int**. This function is an instance of ([Int]) -> Int? type. The function's parameters are listed on the left side of the parentheses and the return type comes after the ->.\n\nLet's look at another example. What type is this function?\n\n```swift\nfunc sayHello() {\n    print(\"Hello\")\n}\n```\n\nIf we don't return anything we don't have to specify that we aren't returning anything in our function declaration. However, this function can be rewritten this way more explicitly.\n\n```swift\nfunc sayHello() -> () {\n    print(\"Hello\")\n}\n```\n\nThis function is an instance of the Type of () -> (). There's a lot to learn with functions. If you want to learn more go to the  [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158) documentation."], ["file_path", "functions"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Heads or Tails\n\nIn this exercise, we are going to focus on writing clean and organized code using functions! When using functions it is important to be descriptive and to organize your code to have a separation of concerns. Let's see this in action:\n\n1.  <span style=\"font-family: Arial, Helvetica, Verdana, Tahoma, sans-serif; font-size: 12px; background-color: initial;\">Create a function tossCoin() -> String</span>\n    *   Have this function print \"Tossing a Coin!\"\n    *   Next have the function randomly pick either \"Heads\" or \"Tails\"\n    *   Have the function print the result\n    *   Finally, have the function return the result\n2.  Now create another function tossMultipleCoins(Int) -> Double\n    *   Have this function call the tossCoin function multiple times based on the Integer input\n    *   Have the function return a Double that reflects the ratio of head toss to total toss"], ["file_path", "heads_or_tails"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Optionals\n\nOptionals are an extremely important part of Swift programming. **Previously in Objective-C, any variable could hold a nil value.** This makes life easier for the developer in many cases but can also lead to many errors when the developer forgets to handle the nil case. **Swift forces the developer to be cautious of potential nil values through the use of Optionals.** An optional is a type that could either hold nil or a value of a specific type. Let's see an example:\n\n```swift\nvar name: String = \"Jay\"  // This is a String type\nvar pet: String?          // This is an Optional String Type\n                          // Right now the val of pet is nil (we've not given it a val, so it has none).\npet = \"Skippy\"\n```\n\nWe know two things about an instance of an  _Optional Type_. **It either has a value or it has no value or nil**. For example, an empty string _\"\" is different from nil. There still is the value from \"\"_. **When it is nil it means there's nothing there.** _Optionals_ signal that an **instance may not have a value**. It warns developers that the value may **potentially be nil**. And **nil is very bad**. When we expect an instance to have a value and it doesn't, our application will crash. As iOS developers, we have to be very cautious of _nil _and **Optionals help us be better programmers and make Swift a safer language.**\n\n```swift\nvar xFactor: String?\n```\n\nHere we declared the variable  _xFactor_ to be of an **Optional Type that may contain an instance of a String Type**. We are declaring this as an _optional_ because_ xFactor_ might potentially be nil and we should not assume _xFactor_ to contain a value in our program. Let's store a value to this_ Optional Type_ and try to print it out. \n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3109/handouts/chapter3109_5324_iOS-Optionals.png)\n\nWe have to first unwrap the _Optional_ before we can use it. It's like a present. We first make sure that it isn't empty by shaking it around. If we hear something then we safely unwrap the present. \n\nDoing something like this is very common in Swift. If an _Optional Type_ is not_ nil _then do something. In fact, this is so common that there is a special syntax to make this process easier. This syntax is called **Optional Binding**.\n\n```swift\nvar present: String? = \"Apple Watch\"\n// If we can let \"unwrappedPresent\" equal \"present\" meaning there is something inside of present then go on to do something with \"unwrappedPresent\"\nif let unwrappedPresent = present {\n    print(\"OMG THANK YOU FOR THE \\(unwrappedPresent)\")\n}\n```\n\n## Force Unwrapping\n\nIf we are 100% confident that the optional has a value and does not hold nil we can use shorthand syntax to unwrap the optional like so:\n\n```swift\nvar present: String? = \"Apple Watch\"        // If we can let \"unwrappedPresent\" equal \"present\"\n                                            // (meaning there is something inside of present)\n                                            // then go on to do something with \"unwrappedPresent\"\nprint(\"OMG THANK YOU FOR THE \\(present!)\")  // Force unwrap using the \"!\"\n```\n\nWe can force-unwrap optionals using the \"!\" operator. Note that this should only be done when we are absolutely sure that the optional holds a value (usually right after the optional has a value assigned to it).\n\n## Implicitly Unwrapped Optionals\n\nImplicitly unwrapped _optionals_ are a little weird. **They are still of the Optional Type**: it can either contain a value or it is nil. The difference is that **we don't need to unwrap them**. With great power comes great responsibility. If we try to access the value of an implicitly unwrapped optional, it will result in a runtime error if it does not have a value. \n\n```swift\nvar present: String! = \"Apple Watch\"         // We don't have to unwrap to use the value,\nprint(\"\\(present)\")\npresent = nil                                // but we can still set it to nil.\nprint(\"\\(present)\")\n```\n\nImplicitly unwrapped _optionals _are reserved for special cases. We will go over them more in depth in a later chapter."], ["file_path", "optionals"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_booleans"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Suits\n\nGiven the following three variables write a for-in loop that will have the following output in the Assistant Editor.\n\n```swift\nlet suits = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\nlet cards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nvar deckOfCards = [String: [Int]]()\n// your code here\nprint(deckOfCards)\n```\n\nOur result should look something like the following:\n\n```\n[\"Clubs\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Diamonds\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Hearts\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], \"Spades\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]\n```\n\nShould you expect the suits to print in the exact order you specified?"], ["file_path", "suits"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.8ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["file_path", "fundamentals"], ["page_ids", "1,2,3,4,5,6,7,8,9"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173537467\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\n**Basic**: Implement only the basic functions of the calculator such as: division, addition, subtraction, and multiplication. Do this with whole numbers only (no decimals).\n\n**Advanced**: implement the following: positive/negative button, percentage button, and the decimal button."], ["file_path", "calculator"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Auto Layout\n\nLet's go back to our _iwanttoplaymystoryboards_ application to demonstrate how Auto Layout can be used. Afterward, we are going to apply Auto Layout again to our iOSQuiz application. **The best way to learn Auto Layout is to keep practicing**. Some people say Auto Layout is the **hardest part about iOS programming and it isn't uncommon to find yourselves spending hours laying out your application and end up deleting all of the constraints and starting over.** You will find plenty of developer frustration over Auto Layout on the Web and it is because **it really pushes developers to think about design differently**. Auto Layout has gotten better over the years and it is a crucial skill for us to master if we want to create one layout that will work across devices and orientations.\n\n<iframe src=\"https://player.vimeo.com/video/142831211\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>\n\nGo to  [Auto Layout Guide](https://developer.apple.com/library/prerelease/watchos/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW1) and read the Introduction, Auto Layout Concepts, and Working with Constraints in Interface Builder. **At first, it may seem like Auto Layout is slowing you down**. It takes time thinking about design in this way. We set specific constraints in our View objects in our storyboard **so that they would know how to adapt depending on screen size and orientations (portrait vs. landscape).** Auto Layout is more important now as Apple has moved on to creating products in all shapes and sizes.\n\nImagine the world without Auto Layout. We would have to create a different layout for all devices and a different one for each orientation. Can you imagine creating a different layout every time a new Apple product is released? **As developers, we need to accept the uncertainty of the various future products Apple will introduce and make sure that the applications that we make can adapt to these new environments**. We set constraints on our View objects so that they know how to adapt to its environment.\n\nWhen we ran our current application, it does not look at all like how we laid it out in the storyboard. And why is our scene so square?! Apple wants us to think about design differently; instead of placing things based on fixed screen width, we create rules for our view objects to adapt to any given scenario. \n\n![](http://i.imgur.com/TMMrY8s.png)\n\nThere are 4 tools available to use in Auto Layout\n\n*   Align popover\n*   Pin popover\n*   Resolve menu\n*   Resizing Behavior menu\n\n## Step 1 [gif-walkthrough](http://i.imgur.com/caHj95B.gif)\n\nWe will be setting constraints on our question label first. **Constraints can either be set between two different View Objects or onto itself**. Our goal is to set just enough constraints so that Xcode will know how to layout our application no matter the screen size or orientation. If we add too much or too little, Xcode will complain to us. **We are going to set the first constraint onto the question label itself**. We are going to give Horizontal Center in Container constraint to our question label by first clicking on the label, adding the constraint in our **Align popover** menu.\n\nAfter we place this constraint, Xcode will complain to us by giving us orange lines. **This is Xcode telling us that our layout is ambiguous: there's more than one possible layout given the constraints**. This is because Xcode can place the question label anywhere as long as it is horizontally centered. We are going to set three more constraints. We are going to \"pin\" the question label to the top, left, and right using the third icon with a measurement of 0 in our **Pin popover** menu. **In the Auto Layout video, we did these steps by control dragging from one object to the object we wanted to create a constraint with. This is just an alternate way and some developers prefer just using the Pin popover menu because it is less error prone when our layout is very complicated.**  Since we have \"Constrain to margin\" selected, question label will go as close as the recommended margin. Then we will set our Lines attribute of our question label to 0 so that the label can move on to the next line if the question is long. **If you are getting warnings regarding frames, click on Resolve menu and click update frames. What the warning is telling you is that given the current constraints, the View Objects might not be placed where you might expect.**\n\n## Step 2: [gif-walkthrough](http://i.imgur.com/Ue9zVPB.gif)\n\nNow let's add constraints to our buttons. First, we want to pin the Answer button with a left value of 0 and top value of Standard Value in our **Pin popover** menu. **Standard Value is the same as 8, but try using Standard Value as much as possible**. **It is important to note that the constraint to the left is different from the constraint to the top in this example.** The first constraint is a **relationship between the Answer button and the super view**. We want the Answer button to be 0 points away from the super view that is the parent view of all subviews. On the other hand, the second constraint is a **relationship between the Answer button and the question label**. We want to be Standard Value away. We can observe and even choose which View objects we want to have a relationship in the same drop-down menu in the Pin Popover.\n\n## Step 3: [gif-walkthrough](http://i.imgur.com/lYwbe3i.gif)\n\nNext, we need to make sure our Next button is laid out properly. We are going to do this by creating a relationship between Answer button and Next button by giving them a baseline constraint in our **Align popover** menu. This means that their baselines will always match up. Now we could pin the Next button to the top and to the right, but we only have to pin it to the right in this case. This is because since the Answer button is already pinned to the top, and has to have matching baselines with Next, Xcode has enough information to place the Next button.\n\n## Step 4: [gif-walkthrough](http://i.imgur.com/TAWlhu1.gif)\n\nNow we just have to place the answer label properly. We are going to give 2 constraints to itself by giving it the Horizontal and Vertical Center to Container. This is creating a relationship between the answer label and the super view. Then we are going to pin the left and the right with a value of 0\\. Now Xcode has enough information to layout our UI.\n\n## Strategies\n\n**Pick one of the top corners and work towards the opposite corner. **Add constraints to the top left most view and move to the bottom right. If we jump around we are bound to overlook something. **Auto Layout is a delicate process and there will be many times where it might just be easier to start all over.**\n\nWe can either run and build your app each time but it is more convenient to have a preview pane open so that you can see our changes in real time. Try to avoid reset to suggested constraints.\n\nAfter we have set all of the constraints open up the size inspector to for each View object and see if you can find any numbers that are not 0 or a Standard Value. Try to use these as much as possible.  If we are doing something other than the standard we should think very carefully if that is really needed."], ["file_path", "auto_layout"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Cold Call\n\nCreate an application that will **pick out a random name from an Array of names every time the cold call button is clicked**. We will be hard coding this Array of names in our View Controller. We will be using Auto Layout in this assignment. Make sure your application has behavior similar to the gif image below:\n\n![](http://i.imgur.com/fhFfVPd.gif)\n\n### Hint\n\nYou can create a random number from 0 to 4 with the following code:\n\n```swift\narc4random_uniform(5)\n```\n\nThis means we can create a random number from 1 to 5 with the following code:\n\n```swift\narc4random_uniform(5) + 1\n```"], ["file_path", "coldcall"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: iOSQuiz\n\n![](http://i.imgur.com/6TJDIwN.gif)\n\nGo ahead and implement answerButtonPressed, nextButtonPressed, and updateUI methods in our ViewController. The hints are in the comments.\n\n```swift\nimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var questionLabel: UILabel!\n    @IBOutlet weak var answerLabel: UILabel!\n    let quizBank = [\n        (\"What is the first step of iOS development?\", \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breath life into our application.\"),\n        (\"Why do we use Autolayout?\", \"We use Autolayout to set constraints on our View objects so that it can adapt to different screen sizes and to different orientations (portrait or landscape)\"),\n        (\"What is the difference between IBAction and IBOutlet?\", \"Both IBAction and IBOutlets are connections from View elements on our storyboard. IBOutlet connects a proprety in our code to an object in a storyboard while an IBAction connects an event generated by an object in a storyboard to a method in our code.\"),\n        (\"What is the Model in MVC responsible for?\", \"Model objects are responsible for the data of our application. It is important to note that Model objects know nothing about the user interface. An example of a Model could be a list of questions and answers.\"),\n        (\"What is the View in MVC responsible for?\", \"View objects are objects that can be seen by the user (objects you drag into the storyboard). Some examples are labels and buttons.\"),\n        (\"What is the Controller in MVC responsible for?\", \"Controller objects facilitate the communication between the Model and the View since the Model and the View should never directly talk to each other (remember the Model knows nothing about the user interface).\")\n    ]\n    var currentQuestion = 0\n    @IBAction func answerButtonPressed(sender: UIButton) {\n        // if answerLabel is not hidden, then make it hidden\n        // else set it not hidden\n    }\n    @IBAction func nextButtonPressed(sender: UIButton) {\n        // if currentQuestion is less than the count of quizBank - 1 then currentQuestion++\n        // else set currentQuestion to 0\n        updateUI()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateUI()\n    }\n    func updateUI() {\n        // set questionLabel's text to equal quizBank[currentQuestion].0\n        // set answerLabel's text to equal quizBank[currentQuestion].1\n        // then set answerLabel to be hidden\n    }\n}\n```\n\nYou can hide a View from the screen by setting its hidden property to true. For example, if we want to hide the questionLabel in our application we can do so by doing the following:\n\n```swift\nquestionLabel.hidden = true\n```"], ["file_path", "iosquiz"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Xcode\n\nGo to [About XCode](https://developer.apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/index.html#//apple_ref/doc/uid/TP40010215-CH1-SW1), read all of \"At a Glance\" and download the latest version of XCode from the Mac App Store. We need to know XCode well. This is where we will spend all of our time building our iOS applications. The main parts of XCode are **Toolbar**, **Navigator**, **Jump Bar**, **Utility Area**, **Editor Area,** and **Debug Area**. \n\n![](http://i.imgur.com/FGI1hqc.png)\n\n## Our First Application\n\n**The best way to learn iOS is by building applications**. Let's go build our first iOS app and name it \"iOSQuiz\". **Go ahead and click create a new project**.\n\n![](http://i.imgur.com/AlUlb6j.gif)\n\nWhen we clicked, create a new project. A template selection window will show. Here we can choose a project template to use as a starting point of our application. We will be using the **Single View Application** for our first application. Then we will be directed to the project options sheet where we have to specify these fields:\n\n*   **Product Name**: This will be the name of our folder that holds the files to our application\n*   **Organization Name**: XCode automatically inserts a copyright notice into every source code file you create\n*   **Organization Identifier**: Use reverse domain name notation (i.e. com.codingdojo)\n*   **Bundle Identifier**: XCode combines the Product Name and Company Identifier to generate a unique Bundle Identifier\n*   **Language**: We will be using Swift.\n*   **Devices**: XCode wants to know what types of devices we are building the application for\n*   **Use Core Data**: Leave this unchecked for now. Core Data is one of the ways we can make data persist in our applications\n\n## Toolbar\n\n![](http://i.imgur.com/s7WOHso.png)\n\n1.  On the left side of the toolbar, we have iTunes like button. **The play button starts building and running our application while the stop button stops it**. \n2.  We can also specify where to run our application to the right of the stop button. **We can either run the application on one of our devices or a host of simulators that XCode provides for us**. \n3.  The box in the middle of our XCode is called the activity view. **Activity View displays and actions or processes that are currently happening**.\n4.  On the right of the Toolbar, we have a section for selecting what kind of editor we want to use and also a series of three buttons that help us maintain the screen real estate on our screen. Currently, the standard editor is selected and it gives you a single pane dedicated to editing a file. **The Venn-diagram button next to the standard editor button splits the editor into two panes and Xcode will try to display two relevant files to you**. If you don't like what XCode gives you, **you can always control which files to display on either screen with the Jump Bar (explained later in the tab)**. You can also select the version editor which is useful when we want to compare different versions of your app when we use source control. \n\n![](http://i.imgur.com/ICaJrll.gif)\n\n## Navigator\n\nThe Navigator is the left-hand side of your XCode. Here we can seamlessly navigate through different aspects of our application. Here are the 8 Navigators available in the Navigator section. We can either click on the icons or we can use Command + 1 to access the Project Navigator (the first one), Command + 2 to access the Symbol Navigator, and so on.\n\n*   **Project Navigator**: List of files that are used in our project.\n*   **Symbol  Navigator**: Symbols are items that the compiler recognizes such as classes, enumerations, and structs.\n*   **Find Navigator**: We can find and replace any part of your application from one search bar.\n*   **Issue Navigator**: Whenever our application fails to build and run we can check out the errors or warnings here.\n*   **Test Navigator**: We can run our unit tests here.\n*   **Debug Navigator**: This is where we will go to debug our application. There are tools that keep track of memory, CPU, and the stack frame. A stack frame is a list of functions that have been called, in the order they were called. If you click on any aspect of the stack frame, we can observe the environment of our application right after that function was called.\n*   **Breakpoint Navigator**: We can make breakpoints in any part of our code so that we can look at the values in variables during that specific time in the life cycle. This is where we can look at all of our breakpoints from one place.\n*   **Log Navigator**: The Log Navigator keeps a history of recent build results and runs logs.\n\n![](http://i.imgur.com/yxr75j6.gif)\n\n## Jump Bar\n\n![](http://i.imgur.com/QiK0neQ.png)\n\n1.  We can access our recent files here, as well as the list of counterparts, superclasses, subclasses, and more.\n2.  The back arrow goes back one file and forward arrow undoes a back arrow. They work in the same way as our browsers.\n3.  This part of the jump bar allows us to navigate files without using the navigator. This area has a segmented pop-up that displays the hierarchical path to reach the selected file in the project. We can click on different parts of the segmented pop-up and XCode will navigate us there.\n\n## Utility Area\n\n![](http://i.imgur.com/HkmuS9H.png)\n\n1.  The upper part of the Utility Area is a **context sensitive panel** which will give you a more detailed information of whatever is being displayed in the editor pane. You can also make changes here depending on what you have selected. For example, if you have a button selected in the editor area, you will be able to change some of its attributes such as size, text, background color in this panel. When a file such as _ViewController.swift_ (we have this clicked in the picture to the left) is in the editor pane, the inspector selector bar will have two different icons, one that looks like a paper, and one with a question mark on it. The paper icon specifies the File inspector where we can view and manage metadata for a file such as its name, type, and path. The question icon specifies Quick Help which gives us details about a symbol. **This is a great place to learn more about specific API classes that we are unsure of.** When we select objects in the Interface Builder, we are given additional selectors. We will go over these more thoroughly later in the chapter.\n2.  The lower part of the Utility Area is where we can **drag and drop different kinds of resources to our project**. One of the primary usages of this part of the Utility Area is the Object Library which is what is selected in the picture to the right. This is where we can drag and drop UI elements onto our Storyboard (discussed later). Things that can be dragged and dropped from this area are File templates, Code snippets, Objects, and Media files.  \n\n## Editor Area\n\n![](http://i.imgur.com/SxWzDPT.png)\n\n**We will either be working with Swift code or the Interface Builder in the Editor Area**. This is where most of our work will be done. We can also display different editors by choosing different editors in the Toolbar mentioned above. We will be going over the Interface Builder more in depth in the next tab as we build out the UI of our application.\n\n## Debug Area\n\n<div>\n\n![](http://i.imgur.com/xH9ld2t.png)\n\nThe left side of the Debug Area is where we can closely observe values in specific variables during a breakpoint in our application. The right side of the Debug Area is where we can see any of our logs that we put in our application. **We log during different parts of the application so that we know that something is hooked up properly or not.**\n\n</div>"], ["file_path", "xcode"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n"], ["file_path", "quiz_layout"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["file_path", "ios_basics"], ["page_ids", "10,11,12,13,14,15"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Storyboards\n\nApple created Storyboards to make life easier for developers. Apple describes a Storyboard as **\"a visual representation of the user interface for an iOS application\".** The beauty of the Storyboard is it allows us to create a robust UI without having to dive into coding. This encourages the tried and true practice of building the UI first before hooking it up to code.\n\nWe will first create a book regarding our passion for iOS using multiple Scenes (screens). This will help us practice transitioning from screen to screen.  **We will then create a new project that does exactly what we did with multiple scenes with just one scene.** **Transitioning between scenes is easy to do but should not be abused. We need to think ****carefully whether**** something deserves its own scene or is part of the current one.** We will use only a single scene in this chapter. **A single scene is very powerful.**\n\n## View Controller + Views\n\nA scene corresponds to a single View Controller and its views. As we will see as we move through the course, every scene has its own View Controller that uses the scene to display many Views to the user. **The Scene defines the layout and placement of different \"Views\" or components on the page while the View Controller manages the Scene as well as all the states of the different Views (components) that make up that Scene.** This will become more and more apparent as we move through the chapter.\n\n## I Want To Play My Storyboards v.1\n\nLet's put our iOSQuiz application on hold for now and start on a new application to illustrate how we go from scene to scene. **We will first go over concepts that we haven't covered yet, to illustrate the role of storyboards (go from one scene to another and see the flow from a high level). We will build an application like this one for an assignment, so this isn't our only opportunity to practice things such as IBOutlet and IBAction. Just focus on the high-level concepts for this tab.**\n\n<iframe src=\"https://player.vimeo.com/video/142831600\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"2\"></iframe>\n\n## I Want To Play My Storyboards v.2\n\n**Just because we can use many scenes doesn't mean we should overuse and abuse them.** It is important to use View Controllers to add logic to a scene and thereby make it more powerful. Let's see this in action with the next video.\n\n<iframe src=\"https://player.vimeo.com/video/142832099\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"3\"></iframe>\n\n## Gotcha\n\n**We have to be careful when removing IBOutlets and IBActions**. Deleting them from our code doesn't ensure that the connection no longer exists. If we get a strange error saying that connections we deleted still exist, click on the ViewController and go to the Connections Inspector to check whether all connections are correctly hooked up.\n\n<iframe src=\"https://player.vimeo.com/video/142832760\" width=\"500\" height=\"281\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\" kwframeid=\"4\"></iframe>\n\n## Connections\n\n**A View Controller's job is to manage a single screen from your app**. **We let a View Controller control our screen by making connections between our UI elements in the Storyboard by control-dragging them into the View Controller code.**\n\n**A connection lets one object know where another object is in memory so that the two objects can communicate. **\n\n*   An **Outlet** points to, or references, an object\n*   An** Action** is a method that gets triggered by a button or some other view that the user interacts with\n\n**An Outlet connects a property in code to a View object in a storyboard. This lets us read and write to the object's properties** like reading a value of a button, or a slider, or the contents of a text field. **An Action connects an event generated by user interaction with a storyboard to a method in our code.** This lets us respond to specific events triggered by objects in our storyboard. You might wonder why we have to specify IBOutlet and IBAction in our code. This syntax is not part of Swift. We put it there so Xcode can figure out to put the little dot there and make it connect to the UI in the storyboard. The IB prefix stands for Interface Builder."], ["file_path", "storyboards"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: Tipster\n\n![](http://i.imgur.com/GS7mPBT.gif)\n\n**Auto Layout is optional**. **Do not spend more than 2 hours trying to properly lay this out**. Hint: we can put two empty views on top and below the digits. We can set a height constraint that is bigger than it can fit on the screen but set its constraint priority to below.\n\n![](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_2666/handouts/chapter2666_3617_tipsterhelper.png)"], ["file_path", "tipster"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n## Assignment: TTT\n\n**Be sure to use the Stack View layout that we presented in the previous chapter. Let's just focus on the logic for this assignment.** Create a Tic Tac Toe game application that has behavior like the following gif below. We can make the colorful squares by using a UIButton without any text.\n\n![](http://i.imgur.com/DZqPQdB.gif)"], ["file_path", "ttt"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "wefoij\n\nwefwefwef\n\nawe f\n<!--YAML\ntitle: UnTitled\n-->\n# User Interface First\n\n**Xcode is designed so that we build the user interface first. Always design how you want the UI to look and then figure out how to make it work with the code.** XCode is perfectly made for this workflow. **We can build our UI by dragging and dropping things such as Labels and Buttons from our Object library**. The reason why we build the UI first is that after we build the UI **we will be able to have a better understanding of our application and, therefore, waste less time figuring out how to make it work.**\n\n## Building our Interface\n\nClick on Main.storyboard and place a Label in the center-top of the square view. Double click on the Label and replace the text inside with \"What is the first step to iOS development?\" You might be wondering why we lay out our UI on a square screen. There are no devices (except for Apple Watch) that have square screens. The Apple Watch is a perfect example why we can no longer think about designing our UI for a specific screen size. **We don't know what kind of products Apple will release, and we already have multitudes of Apple products with varying screen sizes. By designing our UI in a square canvas helps us think about layout in terms of constraints rather than exact placement.** We will be placing constraints using Auto Layout in the next tab.\n\n![](http://i.imgur.com/AOth9XP.gif)\n\n**When we are initially placing View objects into the Storyboard, try to use the guided blue lines as much as possible. This is XCode helping us make better UI.** Next, we are going to drag two buttons out of the Object Library. We can drag and drop the buttons just like we did with the label. One button will be to the left with the text \"Answer\" and the other button will be to the right with the text \"Next.\" \n\n![](http://i.imgur.com/MIkGJVw.gif)\n\nNow we are going to drag and drop another Label in the center of the screen with the following text: \"Create the user interface. As we create the UI, we will get a better understanding of our application. Then we breathe life into our application.\" With default settings, our Label will go off the screen as it tries to fit all of the text in one line. First, we will have to click on the Label and then go to the Utility Area, select the Attributes Inspector and change the number of lines to be 0\\. Once it is set to 0, XCode will wrap the text around once it hits the width of the containing label. We can also set the text here instead of double clicking on the label. \n\n![](http://i.imgur.com/a9geJ24.gif)\n\nWe are done with building our UI! Kind of. Go ahead and press Command + R to build and run your application. **The results might not be what you were expecting. To fix this, we have to add constraints with Auto Layout.**"], ["file_path", "ui_first"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["file_path", "ios_intern"], ["page_ids", "16,17,18,19"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\nThis assignment is optional and should only be attempted by those who have completed all previous assignments earlier than scheduled. If you're not sure if you should complete this assignment, ask your instructor for input.\n\n<iframe src=\"https://player.vimeo.com/video/173536012\" width=\"640\" height=\"400\" frameborder=\"0\" webkitallowfullscreen=\"\" mozallowfullscreen=\"\" allowfullscreen=\"\"></iframe>"], ["file_path", "great_number_game"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Think Different\n\n<iframe width=\"420\" height=\"315\" src=\"https://www.youtube.com/embed/-z4NS2zdrZc\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n(Video courtesy of [Nathan Hulls](https://www.youtube.com/watch?v=-z4NS2zdrZc))\n\n# iOS Programming\n\n**iOS is a mobile operating system developed by Apple**. This means that this class will primarily focus on applications that are running on iOS such as iPhone/iPad/Apple Watch applications. Although we will be primarily focused on building iPhone applications, building for other devices is very similar. OS X is an operating system for MacBooks and Macs. Fortunately, building OS X applications is not that very different either.\n\n# What We Need to Know\n\n*   **Language**: The primary language that we will be using in this course will be Swift. Apple created Swift with the intention of replacing Objective-C. However, we will be examining some Objective-C code to explore _why_ Swift was developed as well as to get you more familiar with Objective-C in case you need to dive into libraries that are written in it.\n*   **Development environment**: Xcode. If we want to develop anything for Apple, it is going to happen inside of Xcode. One of the benefits of having an all-in-one tool for building applications is that we will be spending less time configuring our environment and more time building our applications.\n*   **Frameworks**: There are tons of frameworks. Each framework is basically a course in and of itself. We will be covering some of the frameworks but the goal by the end of the course is **having the ability to read the documentation and figure out how to use a framework of your choice**.\n*   **Patterns**: iOS programming might feel a little bit different at first with protocols, delegates, and blocks. It is important that we know these patterns and implement in our code so that we can collaborate with other developers.\n\n## Prerequisites\n\n*   Solid understanding of the Swift Programming Language\n*   Latest version of Xcode"], ["file_path", "ios"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections I\n\n**Now that we finished building our UI and properly laid it out using Auto Layout, we can start thinking about the implementation of the app**. First, let's make the necessary connections between our scene and our View Controller code.\n\n## Outlets\n\nWill this show up in the git diff?\n\nWe are going to create two Outlets. **We want an Outlet for the question label and the answer label because we want to be able to change the text inside of these labels in our application**. For example, if the user clicks next, we want to display the text of the next question. We do this by control dragging from the storyboard to the View Controller.\n\n![](http://i.imgur.com/ieLJmQ2.gif)\n\n**Now that the labels are wired up, we can change its value in our code.** The labels have a property called text that we can change. **The viewDidLoad() method gets called automatically once our view has loaded**. This is a good place to do some set-up code. Once this message is sent to our View Controller, we will change the text properties of the labels which will result in our application displaying the correct question and answer.\n\n![](http://i.imgur.com/W383YQp.gif)\n"], ["file_path", "connections_i"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Connections II\n\nSetting up an Outlet is **connecting a property from code to a View object** on the Storyboards. Setting up an Action is similar but it is **connecting a method from code to an event that a user can trigger by interacting with one or more View objects**.\n\n## Actions\n\nNow let's set up Actions for our buttons. **Once the user touches the button and releases the finger within the bounds of the button, we want to trigger some lines of code**. For example, when the Answer button is clicked, we might want to to display our Answer label. We specify that the View object that is going to trigger this event is going to be a UIButton. The default is AnyObject but that is too vague. **We want to explicitly state that a UIButton is going to trigger this event.** Then when this code is triggered, the sender object will be passed into the block of code which would be the UIButton that alerted the View Controller about an event.\n\nHere, we specify the Type to be UIButton only because this describes our IBAction a little better. We are saying that this action is going to get triggered by a UIButton. Once the method gets called, it passes a sender argument which is the View object that triggered this action. We can leave it at AnyObject and our code will still work but it is good practice to be more descriptive when we can.\n\n![](http://i.imgur.com/fC1DskU.gif)\n\nNow we can write the lines of code that we want to execute when someone touches up inside our different buttons. We will just log out that a particular button was pressed for now. We will be able to see the results of the log in our Debug Area of our Xcode.![](http://i.imgur.com/Ewl3vYu.gif)"], ["file_path", "connections_ii"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["file_path", "ios_advanced"], ["page_ids", "20,21,22,23"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Creating Your Own Types in Swift\n\nThere are three main ways for us to create our own types in Swift: **Classes, Structs, and Enumerations.** We'll be focusing on Classes and Structs since you will be using them heavily in your own code. Let's start with classes.\n\n## Classes\n\nClasses in Swift allow you to define the blueprint of a particular type and then create instances of that type (also known as Objects). This paradigm of creating your own types and then instantiating them is known as **Object Oriented Programming** and becomes very powerful when creating large scale applications with multiple components. Let's start by creating a class:\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n}\nvar myPerson: Person = Person()\nprint(\"\\(myPerson.species)\")\n```\n\nHere we have created the class Person that has one **property** \"species\" and then we create an instance of the person called \"myPerson\". Note that we are declaring the type of myPerson to be the class that we defined above. This means we can create our own types!\n\n### Stored Properties\n\n```swift\nclass Person {\n    var species = \"H. Sapiens\"\n}\n```\n\nHere the Person class has  **one stored property and it has a default value of \"H. Sapiens\"**. Since we declared the property as a variable it is both readable and writable (meaning we can access it _and_ change it).\n\n```swift\nvar myPerson = Person()                 // Note use of type inference to infer that it is \"Person\" type\nmyPerson.species = \"Homo Sapiens\"       // We can change the property\nprint(\"\\(myPerson.species)\")            // And we can access it!\n```\n\nWe can  **create read-only properties by simply declaring properties as a constant**. Since the values can't be changed, it can't be written which makes it a read-only property.\n\n```swift\nclass Person {\n    let species = \"H. Sapiens\"\n}\nvar myPerson = Person()\nmyPerson.species = \"Homo Sapiens\"       // ! => Cannot assign to 'species' in myPerson\n```\n\n### Methods\n\n**Methods are functions that are associated with a Type**. While properties define what an instance \"knows\", methods define what an instance \"can do\". Let's see methods in action with our Person example.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  func speak() {\n    print(\"Hello! I am a \\(self.species)\")   // Note how we refer to the properties using \"self\"\n  }\n}\nvar myPerson: Person = Person()\nmyPerson.speak()                             // Note we call method similar to how we access properties\n```\n\n### Method Parameter Names\n\nSo far we only implemented methods that take no arguments. Methods and functions are very similar.  **Methods are just functions associated with a Type**. **The first argument of a method does not get an external parameter name**, but all other arguments get external parameter names. If a method only has one argument, the same rule applies which means the argument does not get an external name.\n\n```swift\nclass User {\n    var intelligence = 0\n    func studyForTopic(topic: String, hours: Int) {\n        print(\"I am studying \\(topic) for \\(hours) hours\")\n    }\n}\nvar user = User()\nuser.studyForTopic(\"Math\", hours: 12)\n```\n\nIt is common practice to  **write the name of the first argument in the actual function name** ('Topic') because the **f****irst argument is not going to get an external parameter name**. By following this practice, it becomes very clear what each argument does. **M****ethods do not give free external parameter names for the first argument but do give external parameter names for all arguments afterwards.**\n\n### **Initialization**\n\nInitialization is the **operation of setting up an instance of a type**. It helps us create an instance with appropriate values. So far, we didn't have to worry about initializer because **we have been giving default stored values when defining properties**. However, if we want more control over how an instance of a Type is created, we will have to write our own initializer.\n\nLet's add a name property to our Person class and then add the code to allow a user to specify the name when initializing the instance.\n\n```swift\nclass Person {\n  var species = \"H. Sapiens\"\n  var name: String\n  init(name: String) {   // Note this function doesn't get called explicitly. It is called \n                         // when creating an instance using initialization syntax -- \"Person()\".\n    self.name = name     // Note use of \"self\" here to refer to the name property.\n  }\n  func speak() {\n    print(\"Hello! I am a \\(self.species) and my name is \\(self.name)\")\n                                             // Note how we refer to the properties using \"self\".\n  }\n}\nvar myPerson: Person = Person(name: \"Jay\")   // Now we have to pass a param to Person initialization.\nmyPerson.speak()                             // Note we call method similar to how we access properties.\n```"], ["file_path", "classes"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Arrays\n\nWe often have to combine related values into a collection. Swift provides us with two Collection types: Array and Dictionary. First, we will go over the Array. **Arrays are an ordered collection of values**. On the other hand, **Dictionaries are an unordered collection of key-value pairs**. Let's first go over Arrays. Each position is defined with an index starting at 0\\. It's a lot easier to explain with examples.\n\nWe will declare a variable _toDoList_ to be of an **instance of the Array Type** which will hold onto an **ordered collection of instances of the String Type**. The [] brackets denote the Array type and inside of the brackets we place the type of the values that we'll be storing.\n\n```swift\nvar toDoList: [String] = [\"Learn iOS\", \"Build the next Flappy Bird\", \"Retire in Cancun\"]\n```\n\nHere we are declaring the toDoList _and_ giving it some values to begin with. What if we wanted to start with no tasks and then gradually add them on? We would have to initialize an empty array like so:\n\n```swift\nvar toDoList: [String] = [String]()              // Setting the array type and initializing the array\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nEvery Instance of Array has the \"append\" method that allows you to add elements to the Array collection.\n\nNow if we are initializing an instance of an _Array Type_ that will hold onto instances of the _String Type_, we can get rid of the type annotation because Swift will be able to infer its type with_ [String]()_ just like value types.\n\n```swift\nvar toDoList = [String]()\ntoDoList.append(\"Learn iOS\")\ntoDoList.append(\"Build the next Flappy Bird\")\ntoDoList.append(\"Retire in Cancun\")\nprint(toDoList)\n```\n\nJust like how we could not assign an_ Int _to a variable or a constant that was declared to hold a different _Type_, if we try to append an instance of a _Type_ that is not a _String_, Swift will throw us an error.\n\n![](http://i.imgur.com/kGFlfDV.png)\n\nAccessing Arrays\n\nArrays are zero indexed. What this means is the first instance inside of an _Array_ lives at index 0\\. The second instance inside of an Array lives at index 1. \n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]      // Note that we let Swift infer the type here\n// The first number lives at index 0.\nprint(\"\\(arrayOfInts[0])\")\n// The second number lives at index 1.\nprint(\"\\(arrayOfInts[1])\")\n// The third number lives at index 2.\nprint(\"\\(arrayOfInts[2])\")\n// The fourth number lives at index 3.\nprint(\"\\(arrayOfInts[3])\")\n// The fifth number lives at index 4.\nprint(\"\\(arrayOfInts[4])\")\n```\n\nWe used ranges in our _for-in_ loops. Ranges can be used to index instances of the _Array Type_ as well.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\n// => \"[1, 2]\"\nprint(\"\\(arrayOfInts[0...1])\")\n// => \"[2, 3, 4]\"\nprint(\"\\(arrayOfInts[1..<4])\")\n// => \"[3, 4]\"\nprint(\"\\(arrayOfInts[2...3])\")\n```\n\nAfter we access an Array using its index, we can set the value at that particular index as well.\n\n```swift\nvar arr = [1, 2, 3, 4]\narr[0] = 8\nprint(arr)      // The array has now changed!\n```\n\n## Methods and Properties\n\nArrays have several methods and properties -- these are just a few that will help you use and modify your collections.\n\n### append()\n\n<div style=\"line-height: 18px;\">We already saw how we could append instances to an _Array_. We use the append method to add a given element to the array. This method is very similar to push methods in other languages:</div>\n\n```swift\nvar nums = [1, 2, 3, 4]\nnums.append(5)\nprint(nums)\n```\n\n### removeAtIndex()\n\nWe can run the method _removeAtIndex_ on an Array and provide the index of the element we want to delete. This method is going to return the particular instance that we are removing from the_ Array_ while removing that instance from the _Array._\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\nvar popped = arrayOfInts.removeAtIndex(0)\nprint(popped)\nprint(arrayOfInts)\n```\n\n### insert()\n\nWe run the _insert_ method with two arguments. The first argument is the value that we would like to add to the _Array _and the second argument is the index where we would like to insert it. When we pass in the second argument, we have to give it a name _atIndex_. We will be going over these named parameters more in the Functions tab.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: 5)\n```\n\n### count\n\nThe _Count _is a property of the_ Array Types._ It holds the total number of elements in an _Array. _This property is very useful when we are looping through an _Array._ We can write the previous code using the count method.\n\n```swift\nvar arrayOfInts = [1, 2, 3, 4, 5]\narrayOfInts.insert(6, atIndex: arrayOfInts.count - 1)\n```\n\n## Looping Through Arrays\n\nThe _for-in_ loop makes looping through all instances within an _Array_ a breeze.\n\n```swift\nvar starters = [\"Fisher\", \"Kobe\", \"Gasol\", \"Bynum\", \"World Peace\"]\nfor starter in starters {\n    print(starter)\n}\n```\n\nOr we can use a range as well along with the count property:\n\n```swift\nfor i in 0..<starters.count {\n    print(starters[i])\n}\n```"], ["file_path", "arrays"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "Calculator"], ["content", "<!--YAML\ntitle: Calculator\n-->\n# Animals\n\n### Objective\n\nThe objective of this assignment is to help you understand inheritance and how classes can be used to help organize your code. Apple gives us access to the iOS framework to build mobile applications, and the different APIs in the framework are built on heavy OOP principles that involve inheritance. Therefore, it is extremely important to understand inheritance so that you can navigate the iOS landscape more easily. \n\n### To Do\n\n**First, create a class called Animal**\n\n1.  Give Animal a property \"name\"\n2.  Give Animal a property \"health\" with a default value of 100\n3.  Give Animal an initialization that takes in a name and sets the name property appropriately\n4.  Give the animal a displayHealth method\n\n**Next, create a subclass of Animal called Cat**\n\n1.  Give the Cat a method \"growl\" that prints to the screen \"Rawr!\"\n2.  Modify the Cat's health to be 150\n3.  Give the Cat a method \"run\" that prints to the screen \"Running\" and deducts 10 health\n\n**Next, create two subclasses of Cat - Cheetah and Lion**\n\n1.  Override the growl method of the Lion to make it print \"ROAR!!!! I am the King of the Jungle\"\n2.  Override Lion's health to be 200\n3.  Override the Cheetah's run method to print \"Running Fast\" and deduct 50 health \n4.  Add a sleep function to the Cheetah class that adds 50 health (make sure that the Cheetah's health limit remains 200)\n\n**Create a Cheetah. Have the Cheetah run 4 times. Display the Cheetah's health. Now modify the _Cat's_ run method so that it cannot run if it does not have the required health.**\n\n**Create a Lion. Have the Lion run 3 times. Have the Lion growl.**\n\nUploadyour playground below."], ["file_path", "animals"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Conditionals\n\n<div> We use conditionals to **execute code based on a specific logical condition**. For example, let's say we are having a party for NBA Legends. We only want to allow players with at least 5 rings. We could write the logic something like this:</div>\n\n```swift\n// Declare a variable called rings that is of the Int Type.\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nIf we have more than one condition we can add an _else if_ statement:\n\n```swift\nvar rings = 5\nif rings >= 5 {\n    print(\"You are welcome to join the party\")\n} else if rings > 2 {\n    print(\"Decent...but \\(rings) rings aren't enough\")\n} else {\n    print(\"Go win some more rings\")\n}\n```\n\nWe used two comparison operators here. First, we checked if rings were greater than equal to 5\\. We also checked if rings were greater than 2\\. Here is a list of Swift's comparison operators:\n\n## Comparison Operators\n\n## ![](http://i.imgur.com/WzRERYY.png)\n\n## Equality vs. Identity\n\n**There is a difference between equality and identity**. For example == checks whether the instances on the left and the right are equal. **Two instances can be equal, but they don't need to have the same location in memory**. The last two operators are called identity operators. We will be going over the differences more in depth once we start creating our own Data Types.\n\n## Logical Operators\n\n![](http://i.imgur.com/pZx0B28.png)\n\nWe can use Logical Operators in our Conditionals as well. Let's say we want to change the criteria for entering our NBA Legends party. Let's say you have to have at least 5 rings AND have the name Kobe to enter the party:\n\n```swift\nvar rings = 5\nlet name = \"Kobe\"\nif rings >= 5 && name == \"Kobe\" {\n  print(\"Welcome to the party \\(name), congratulations on your \\(rings) rings\")\n}\n```\n\nWe can change our criteria and say that you have to have at least 5 rings or have at least 3 All-Star appearances.\n\n```swift\nvar rings = 5\nvar numOfAllStarAppearances = 17\nif rings >= 5 || numOfAllStarAppearances > 3 {\n  print(\"Welcome you are truly a legend\")\n}\n```\n\nOr we can just let in everyone who is not crazy.\n\n```swift\nvar crazy = true\nif !crazy {\n    print(\"Let's party!\")\n}\n```"], ["file_path", "conditionals"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["file_path", "frameworks"], ["page_ids", "24,25,26,27"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Value vs Reference Types\n\nEvery type in Swift falls into one of **two categories: Value Types or Reference Types.** The easiest way to remember which is which is to remember that **Classes and Functions are the only Reference types** and everything else is a Value Type. But what does Value Type actually mean? \n\n**Value types are copied ** (if you change the value of the copy, you will not change the original) when they are **assigned to a variable or a constant** and **when they are passed in as an argument to a function**.\n\nOn the other hand, **Reference types** are not copied. Instead, their **memory address location **is passed back and forth so changing the value of a Reference Type will change all of the \"pointers\" (variables or arguments) that refer to that object. \n\nLet's take a look at an example:\n\n```swift\nclass Person {\n  var fullName: String\n  init(name: String) {\n    self.fullName = name\n  }\n  func introduce() {\n    print(\"Hi my name is \\(self.fullName)\")\n  }\n}\nvar j = Person(name: \"Ketul Patel\") // Initialize a Person object and assign it to the j variable\nvar k = j                           // Create a k variable and set its value to be the j variable\n                                    // (remember classes are reference types) \nj.introduce()                       // Prints \"Hi my name is Ketul Patel\"\nk.fullName = \"Ketul J Patel\"        // We are changing the name through the k variable.\nj.introduce()                       // Prints \"Hi my name is Ketul J Patel\" since both\n                                    // j and k refer to the same instance in memory\n```\n\nWhoa, that's a lot of confusing code! Let's walk through it step by step.\n\n1.  We create the Person class that has a \"fullName\" property and an introduce method\n2.  We create an instance of Person and assign it to the \"j\" variable. This instance has the value \"Ketul Patel\" stored in the fullName property\n3.  We create another variable \"k\" and assign it to the \"j\" variable. Since classes are reference types instead of copying the instance in the \"j\" variable we simply point both \"k\" and \"j\" to the same instance in memory\n4.  Since k and j refer to the same instance, when we change the value by referencing the instance through the k variable it changes the value for j as well (one instance in memory referred to by 2 variables or \"pointers\")\n\n**In contrast, Structs are Value Types which means that when they are passed, their values are copied and then passed. **\n\nLet's take a look at an example of this:\n\n```swift\nstruct Rectangle {\n  var width: Int\n  var height: Int\n}\nvar square1 = Rectangle(width: 10, height: 10)\nvar square2 = square1                         // Here the val inside square 1 (an instance of Rectangle)\n                                              // is copied and passed rather than just pointed to.\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are the same because square2 is a copy of square1\nsquare2.width = 20                            // This only changes square2 because there are\n                                              // 2 separate instances of rectangle in memory\nsquare2.height = 20\nprint(\"square1's width: \\(square1.width), square2's width \\(square2.width)\") \n                                              // They are different now: changing square2 changed a\n                                              // completely separate instance from square1.\n```\n\nThe major difference between Structs and Classes is the Value vs Reference Types that we see in the examples above. Remember that we **pass types in 2 main ways -- pass to a variable and pass to a function**. \n\n**Every type in Swift that is not an instance of a class or function is a Value Type. This includes Strings, Arrays, and Dictionaries which are implemented internally as Structs in Swift. **\n\nThe only way to pass a Value Type by memory location is by using the **inout** designation when passing the Value type as an argument to a function."], ["file_path", "value_vs_reference_types"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals I\n\nUsing your knowledge of variables, constants, and types fix the following code:\n\n```swift\nvar type: String = \"Rectangle\"\nvar description: String = \"A quadrilateral with four right angles\"\nvar width: Int = 5\nvar height: Double = 10.5\nvar area: Double = width * height\nheight++\nwidth++\narea = width * height\n// Note how you can \"interpolate\" variables into Strings using the following syntax\nprint(\"The shape is a \\(type) or \\(description) with an area of \\(area)\")\n```\n\nSwift's string interpolation lets us **inject constant and variables into a new String**. This allows constructing instances of String Type a breeze. Anything inside of the parenthesis in \\() gets evaluated and gets injected into the string. We can even put expressions inside of the parenthesis and Swift will evaluate it first and then inject it into the instance of the _String Type_.\n\n```swift\nvar numberOfChampionships = 5\nlet name = \"Kobe\"\nprint(\"My favorite player is \\(name) and he has \\(numberOfChampionships) rings\")\nprint(\"His jersey number is \\(8 * 3)\")\n```\n\nYou can download the playground [here](http://s3.amazonaws.com/General_V88/boomyeah/company_209/chapter_3535/handouts/chapter3535_5392_SwiftFundamentalsI.playground.zip)"], ["file_path", "swift_fundamentals_i"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals II\n\nIt's important that you get familiar with using Swift variables and constants as well as if/else statements and loops. After all, understanding how to use these components make up the majority of what builds your apps. The basic assignments are to help you master some of these basic concepts.\n\nPlease create a playground and finish these exercises before uploading.\n\n1.  First, create a loop (either for or while) that prints all of the values from 1-255\n2.  Next, create a program that prints all of the values from 1-100 that are divisible by 3 or 5 but not both\n3.  Now modify that program to print \"Fizz\" when the number is divisible by 3 and \"Buzz\" when the number is divisible by 5 as well as \"FizzBuzz\" when the number is divisible by both! (See Below).\n\nTo check divisibility you can use the module operator like so:\n\n```swift\nvar number = 2\nif number % 2 == 0 {\n    print(\"Number is even\")\n} else {\n    print(\"Number is odd\")\n}\n```"], ["file_path", "swift_fundamentals_ii"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "content", "file_path", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"[0m  [["title", "UnTitled"], ["content", "<!--YAML\ntitle: UnTitled\n-->\n# Swift Fundamentals III\n\nIn this set of exercises, we'll be adding to our knowledge of the basic building blocks by incorporating Arrays.\n\nComplete the following exercises in a playground and upload your code below.\n\n1.  Write a program that adds the numbers 1-255 to an array\n2.  Swap two random values in the array \n    *   **Hint:** you can use the _arc4random_uniform(UInt32)_ function to get a random number from 0 to the number passed in. The arc4random_uniform function takes in one parameter that is of the UInt32 type and returns a random number that is of the UInt32 type. How can you deal with this using your knowledge of types?\n3.  Now write the code that swaps random values 100 times (You've created a \"Shuffle\"!)\n4.  Remove the value \"42\" from the array and Print \"We found the answer to the Ultimate Question of Life, the Universe, and Everything at index __\" and print the index of where \"42\" was before you removed it."], ["file_path", "swift_fundamentals_iii"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "file_path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["file_path", "intro_to_osx"], ["page_ids", "28,29,30,31"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "file_path", "chapter_ids", "last_commit", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["file_path", "ios"], ["chapter_ids", "1,2,3,4,5,6"], ["last_commit", "3aabdba706bc325715ae85fffed57ddb08a18926"], ["created_at", 2017-01-22 18:58:30 UTC], ["updated_at", 2017-01-22 18:58:30 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mCourse Load (1.2ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mCourse Load (0.7ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mCourse Load (1.4ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mChapter Load (1.6ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters"[0m
  [1m[36mPage Load (2.8ms)[0m  [1m[34mSELECT "pages".* FROM "pages"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mPage Load (4.3ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" ORDER BY "pages"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mPage Load (0.2ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."file_path" = $1 LIMIT $2[0m  [["file_path", "structs"], ["LIMIT", 1]]
  [1m[36mPage Load (0.3ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."file_path" = $1 LIMIT $2[0m  [["file_path", "structs"], ["LIMIT", 1]]
  [1m[35mSQL (5.6ms)[0m  [1m[31mDELETE FROM "pages" WHERE "pages"."id" = $1[0m  [["id", 1]]
  [1m[36mPage Load (0.3ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" ORDER BY "pages"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.4ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (132.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (133.4ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (487.5ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (376.3ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (1.7ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (16.4ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.1ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (10.0ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.3ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (5.0ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (3.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.5ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.2ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 20:45:30 UTC], ["updated_at", 2017-01-22 20:45:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (2.7ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (17.0ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "file_path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.3ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (4.5ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "file_path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (3.7ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.3ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (3.6ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.2ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.0ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.8ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.5ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 20:45:30 UTC], ["updated_at", 2017-01-22 20:45:30 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."title" = $1 LIMIT $2[0m  [["title", "hi"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.2ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (118.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (120.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (14.9ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (2.3ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.7ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreateCourses (20170122172219)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172219"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateChapters (20170122172344)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172344"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePages (20170122172554)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172554"]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateUsers (20170122172732)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172732"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateEnrollments (20170122172805)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (10.0ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
, CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments"  ("course_id")[0m
  [1m[35m (0.6ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments"  ("user_id")[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172805"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePageVisits (20170122172941)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits"  ("user_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits"  ("page_id")[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172941"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 20:46:58 UTC], ["updated_at", 2017-01-22 20:46:58 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.0ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "hi"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.0ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.9ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.3ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (130.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (131.0ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (500.6ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_development" ENCODING = 'unicode'[0m
  [1m[35m (490.4ms)[0m  [1m[35mCREATE DATABASE "courses-clone-api_test" ENCODING = 'unicode'[0m
  [1m[35mSQL (1.8ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (16.5ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (6.9ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (4.5ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (0.9ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.7ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 21:36:56 UTC], ["updated_at", 2017-01-22 21:36:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.2ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35mSQL (1.4ms)[0m  [1m[35mCREATE EXTENSION IF NOT EXISTS "plpgsql"[0m
  [1m[35m (18.2ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (1.6ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments" USING btree ("course_id")[0m
  [1m[35m (1.1ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments" USING btree ("user_id")[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits" USING btree ("page_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits" USING btree ("user_id")[0m
  [1m[35m (2.9ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (5.7ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
[0m
  [1m[35m (1.4ms)[0m  [1m[35mALTER TABLE "enrollments" ADD CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
[0m
  [1m[35m (1.0ms)[0m  [1m[35mALTER TABLE "page_visits" ADD CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (0.8ms)[0m  [1m[34mSELECT version FROM "schema_migrations"[0m
  [1m[35m (0.4ms)[0m  [1m[32mINSERT INTO "schema_migrations" (version) VALUES ('20170122172941')[0m
  [1m[35m (0.3ms)[0m  [1m[32mINSERT INTO schema_migrations (version) VALUES
('20170122172219'),
('20170122172344'),
('20170122172554'),
('20170122172732'),
('20170122172805');

[0m
  [1m[35m (2.1ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[36mActiveRecord::InternalMetadata Load (2.9ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 21:36:57 UTC], ["updated_at", 2017-01-22 21:36:57 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.1ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (1.1ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.3ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::InternalMetadata Load (1.5ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (0.1ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (120.5ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (120.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (0.1ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (0.2ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (14.9ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (3.6ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.7ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreateCourses (20170122172219)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172219"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateChapters (20170122172344)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172344"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePages (20170122172554)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172554"]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateUsers (20170122172732)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (3.0ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172732"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateEnrollments (20170122172805)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (9.3ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
, CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
)[0m
  [1m[35m (0.9ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments"  ("course_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments"  ("user_id")[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172805"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePageVisits (20170122172941)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits"  ("user_id")[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits"  ("page_id")[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172941"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 21:37:21 UTC], ["updated_at", 2017-01-22 21:37:21 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.9ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."id" = $1 LIMIT $2[0m  [["id", 0], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.6ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (1.2ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "ar_internal_metadata"."value" FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1[0m  [["key", :environment]]
  [1m[35m (118.9ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_development"[0m
  [1m[35m (118.6ms)[0m  [1m[35mDROP DATABASE IF EXISTS "courses-clone-api_test"[0m
  [1m[35m (18.3ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying PRIMARY KEY)[0m
  [1m[35m (2.7ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying PRIMARY KEY, "value" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3757099930236027165);[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.8ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
Migrating to CreateCourses (20170122172219)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (3.5ms)[0m  [1m[35mCREATE TABLE "courses" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "chapter_ids" character varying, "last_commit" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172219"]]
  [1m[35m (0.5ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateChapters (20170122172344)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.5ms)[0m  [1m[35mCREATE TABLE "chapters" ("id" serial primary key, "title" character varying, "description" character varying, "path" character varying, "page_ids" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172344"]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePages (20170122172554)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.4ms)[0m  [1m[35mCREATE TABLE "pages" ("id" serial primary key, "title" character varying, "content" character varying, "path" character varying, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172554"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateUsers (20170122172732)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.8ms)[0m  [1m[35mCREATE TABLE "users" ("id" serial primary key, "email" character varying, "first_name" character varying, "last_name" character varying, "password_digest" character varying, "admin_level" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL)[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172732"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateEnrollments (20170122172805)
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (10.3ms)[0m  [1m[35mCREATE TABLE "enrollments" ("id" serial primary key, "course_id" integer, "user_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_2e119501f4"
FOREIGN KEY ("course_id")
  REFERENCES "courses" ("id")
, CONSTRAINT "fk_rails_e860e0e46b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
)[0m
  [1m[35m (0.8ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_course_id" ON "enrollments"  ("course_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_enrollments_on_user_id" ON "enrollments"  ("user_id")[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172805"]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreatePageVisits (20170122172941)
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (2.6ms)[0m  [1m[35mCREATE TABLE "page_visits" ("id" serial primary key, "user_id" integer, "page_id" integer, "created_at" timestamp NOT NULL, "updated_at" timestamp NOT NULL, CONSTRAINT "fk_rails_28bbe0e62b"
FOREIGN KEY ("user_id")
  REFERENCES "users" ("id")
, CONSTRAINT "fk_rails_ca9a23129d"
FOREIGN KEY ("page_id")
  REFERENCES "pages" ("id")
)[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_user_id" ON "page_visits"  ("user_id")[0m
  [1m[35m (0.7ms)[0m  [1m[35mCREATE  INDEX  "index_page_visits_on_page_id" ON "page_visits"  ("page_id")[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20170122172941"]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.7ms)[0m  [1m[34mSELECT  "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", :environment], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", 2017-01-22 21:38:56 UTC], ["updated_at", 2017-01-22 21:38:56 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_advisory_unlock(3757099930236027165)[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.8ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.7ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "fundamentals"], ["LIMIT", 1]]
  [1m[36mPage Load (1.0ms)[0m  [1m[34mSELECT "pages".* FROM "pages"[0m
  [1m[36mChapter Load (1.1ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters"[0m
  [1m[36mCourse Load (1.1ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.2ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.9ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.8ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "fundamentals"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.3ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "fundamentals"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.3ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (1.1ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mActiveRecord::SchemaMigration Load (1.3ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.7ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.3ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "Calculator"], ["path", "ios/frameworks/animals"], ["created_at", 2017-01-22 21:51:13 UTC], ["updated_at", 2017-01-22 21:51:13 UTC]]
  [1m[35m (1.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/arrays"], ["created_at", 2017-01-22 21:51:16 UTC], ["updated_at", 2017-01-22 21:51:16 UTC]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/classes"], ["created_at", 2017-01-22 21:51:17 UTC], ["updated_at", 2017-01-22 21:51:17 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/conditionals"], ["created_at", 2017-01-22 21:51:17 UTC], ["updated_at", 2017-01-22 21:51:17 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/deck_of_cards"], ["created_at", 2017-01-22 21:51:18 UTC], ["updated_at", 2017-01-22 21:51:18 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/dictionaries"], ["created_at", 2017-01-22 21:51:18 UTC], ["updated_at", 2017-01-22 21:51:18 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/functions"], ["created_at", 2017-01-22 21:51:18 UTC], ["updated_at", 2017-01-22 21:51:18 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/heads_or_tails"], ["created_at", 2017-01-22 21:51:18 UTC], ["updated_at", 2017-01-22 21:51:18 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/hello_swift_file_renamed"], ["created_at", 2017-01-22 21:51:18 UTC], ["updated_at", 2017-01-22 21:51:18 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/inheritance"], ["created_at", 2017-01-22 21:51:19 UTC], ["updated_at", 2017-01-22 21:51:19 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/let_and_var"], ["created_at", 2017-01-22 21:51:19 UTC], ["updated_at", 2017-01-22 21:51:19 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/loops"], ["created_at", 2017-01-22 21:51:19 UTC], ["updated_at", 2017-01-22 21:51:19 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/numerical_types"], ["created_at", 2017-01-22 21:51:19 UTC], ["updated_at", 2017-01-22 21:51:19 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/optionals"], ["created_at", 2017-01-22 21:51:19 UTC], ["updated_at", 2017-01-22 21:51:19 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/playground"], ["created_at", 2017-01-22 21:51:20 UTC], ["updated_at", 2017-01-22 21:51:20 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_booleans"], ["created_at", 2017-01-22 21:51:20 UTC], ["updated_at", 2017-01-22 21:51:20 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_swift_basics"], ["created_at", 2017-01-22 21:51:20 UTC], ["updated_at", 2017-01-22 21:51:20 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_types"], ["created_at", 2017-01-22 21:51:20 UTC], ["updated_at", 2017-01-22 21:51:20 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/structs"], ["created_at", 2017-01-22 21:51:20 UTC], ["updated_at", 2017-01-22 21:51:20 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/suits"], ["created_at", 2017-01-22 21:51:21 UTC], ["updated_at", 2017-01-22 21:51:21 UTC]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_i"], ["created_at", 2017-01-22 21:51:21 UTC], ["updated_at", 2017-01-22 21:51:21 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_ii"], ["created_at", 2017-01-22 21:51:21 UTC], ["updated_at", 2017-01-22 21:51:21 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_iii"], ["created_at", 2017-01-22 21:51:21 UTC], ["updated_at", 2017-01-22 21:51:21 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/value_vs_reference_types"], ["created_at", 2017-01-22 21:51:22 UTC], ["updated_at", 2017-01-22 21:51:22 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/connections_i"], ["created_at", 2017-01-22 21:51:22 UTC], ["updated_at", 2017-01-22 21:51:22 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/connections_ii"], ["created_at", 2017-01-22 21:51:22 UTC], ["updated_at", 2017-01-22 21:51:22 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/great_number_game"], ["created_at", 2017-01-22 21:51:23 UTC], ["updated_at", 2017-01-22 21:51:23 UTC]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/ios"], ["created_at", 2017-01-22 21:51:23 UTC], ["updated_at", 2017-01-22 21:51:23 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "Auto Layout"], ["path", "ios/ios_basics/auto_layout"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/calculator"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/coldcall"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/coldcall_v2"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/iosquiz"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/ninja_gold"], ["created_at", 2017-01-22 21:51:24 UTC], ["updated_at", 2017-01-22 21:51:24 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/quiz_connections"], ["created_at", 2017-01-22 21:51:25 UTC], ["updated_at", 2017-01-22 21:51:25 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/quiz_layout"], ["created_at", 2017-01-22 21:51:25 UTC], ["updated_at", 2017-01-22 21:51:25 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/README"], ["created_at", 2017-01-22 21:51:25 UTC], ["updated_at", 2017-01-22 21:51:25 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/stack_views"], ["created_at", 2017-01-22 21:51:25 UTC], ["updated_at", 2017-01-22 21:51:25 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/xcode"], ["created_at", 2017-01-22 21:51:26 UTC], ["updated_at", 2017-01-22 21:51:26 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/storyboards"], ["created_at", 2017-01-22 21:51:26 UTC], ["updated_at", 2017-01-22 21:51:26 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/tipster"], ["created_at", 2017-01-22 21:51:26 UTC], ["updated_at", 2017-01-22 21:51:26 UTC]]
  [1m[35m (0.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/ttt"], ["created_at", 2017-01-22 21:51:26 UTC], ["updated_at", 2017-01-22 21:51:26 UTC]]
  [1m[35m (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/ui_first"], ["created_at", 2017-01-22 21:51:27 UTC], ["updated_at", 2017-01-22 21:51:27 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.2ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "classes"], ["LIMIT", 1]]
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[36mPage Load (1.4ms)[0m  [1m[34mSELECT "pages".* FROM "pages"[0m
  [1m[36mPage Load (2.2ms)[0m  [1m[34mSELECT "pages".* FROM "pages"[0m
  [1m[36mChapter Load (1.0ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters"[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.5ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.4ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.5ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "Calculator"], ["path", "ios/frameworks/animals"], ["created_at", 2017-01-22 21:53:53 UTC], ["updated_at", 2017-01-22 21:53:53 UTC]]
  [1m[35m (1.0ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::SchemaMigration Load (0.4ms)[0m  [1m[34mSELECT "schema_migrations".* FROM "schema_migrations"[0m
  [1m[36mCourse Load (0.6ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" WHERE "courses"."path" = $1 LIMIT $2[0m  [["path", "ios"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (1.0ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "Calculator"], ["path", "ios/frameworks/animals"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (1.8ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/arrays"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/classes"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/frameworks/conditionals"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/deck_of_cards"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/dictionaries"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/functions"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/heads_or_tails"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (3.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/hello_swift_file_renamed"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/inheritance"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/let_and_var"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/loops"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/numerical_types"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/optionals"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/playground"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_booleans"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_swift_basics"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (2.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/quiz_types"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/structs"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/fundamentals/suits"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_i"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_ii"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/swift_fundamentals_iii"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.1ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/intro_to_osx/value_vs_reference_types"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/connections_i"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/connections_ii"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/great_number_game"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_advanced/ios"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "Auto Layout"], ["path", "ios/ios_basics/auto_layout"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/calculator"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/coldcall"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/coldcall_v2"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/iosquiz"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/ninja_gold"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/quiz_connections"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/quiz_layout"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/README"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/stack_views"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.4ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_basics/xcode"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/storyboards"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/tipster"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/ttt"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "pages" ("title", "path", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["title", "UnTitled"], ["path", "ios/ios_intern/ui_first"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (1.4ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/frameworks/classes"], ["LIMIT", 1]]
  [1m[36mPage Load (0.4ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/frameworks/arrays"], ["LIMIT", 1]]
  [1m[36mPage Load (0.3ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/frameworks/animals"], ["LIMIT", 1]]
  [1m[36mPage Load (0.2ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/frameworks/conditionals"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.6ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Frameworks"], ["description", "Additional Frameworks For iOS"], ["path", "ios/frameworks"], ["page_ids", "3,2,1,4"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.4ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.2ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/structs"], ["LIMIT", 1]]
  [1m[36mPage Load (0.2ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/deck_of_cards"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/playground"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/dictionaries"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/functions"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/heads_or_tails"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/optionals"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/quiz_booleans"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals/suits"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "fundamentals"], ["description", "The Fundamentals of iOS"], ["path", "ios/fundamentals"], ["page_ids", "19,5,15,6,7,8,14,16,20"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/intro_to_osx/value_vs_reference_types"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/intro_to_osx/swift_fundamentals_i"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/intro_to_osx/swift_fundamentals_ii"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/intro_to_osx/swift_fundamentals_iii"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "Intro To OSX"], ["description", "Build for your Computer"], ["path", "ios/intro_to_osx"], ["page_ids", "24,21,22,23"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_advanced/great_number_game"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_advanced/ios"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_advanced/connections_i"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_advanced/connections_ii"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Advanced"], ["description", "It's so frickin advanced"], ["path", "ios/ios_advanced"], ["page_ids", "27,28,25,26"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/calculator"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/auto_layout"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/coldcall"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/iosquiz"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/xcode"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics/quiz_layout"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Basics"], ["description", "Just the frickin basics"], ["path", "ios/ios_basics"], ["page_ids", "30,29,31,33,39,36"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_intern/storyboards"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_intern/tipster"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_intern/ttt"], ["LIMIT", 1]]
  [1m[36mPage Load (0.1ms)[0m  [1m[34mSELECT  "pages".* FROM "pages" WHERE "pages"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_intern/ui_first"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.2ms)[0m  [1m[32mINSERT INTO "chapters" ("title", "description", "path", "page_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Intermediate"], ["description", "Just in between"], ["path", "ios/ios_intern"], ["page_ids", "40,41,42,43"], ["created_at", 2017-01-22 21:54:15 UTC], ["updated_at", 2017-01-22 21:54:15 UTC]]
  [1m[35m (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mChapter Load (0.2ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/fundamentals"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.1ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_basics"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.1ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_intern"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.1ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/ios_advanced"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.1ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/frameworks"], ["LIMIT", 1]]
  [1m[36mChapter Load (0.1ms)[0m  [1m[34mSELECT  "chapters".* FROM "chapters" WHERE "chapters"."path" = $1 LIMIT $2[0m  [["path", "ios/intro_to_osx"], ["LIMIT", 1]]
  [1m[35m (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35mSQL (0.3ms)[0m  [1m[32mINSERT INTO "courses" ("title", "description", "path", "chapter_ids", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["title", "iOS Development"], ["description", "Learn to Develop iOS Applications for iPhones"], ["path", "ios"], ["chapter_ids", "2,5,6,4,1,3"], ["created_at", 2017-01-22 21:54:31 UTC], ["updated_at", 2017-01-22 21:54:31 UTC]]
  [1m[35m (0.7ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mCourse Load (2.4ms)[0m  [1m[34mSELECT "courses".* FROM "courses"[0m
  [1m[36mCourse Load (0.3ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" ORDER BY "courses"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mChapter Load (1.5ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters" WHERE "chapters"."id" IN (2, 5, 6, 4, 1, 3)[0m
  [1m[36mCourse Load (5.5ms)[0m  [1m[34mSELECT  "courses".* FROM "courses" ORDER BY "courses"."id" ASC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mChapter Load (0.3ms)[0m  [1m[34mSELECT "chapters".* FROM "chapters" WHERE "chapters"."id" IN (2, 5, 6, 4, 1, 3)[0m
  [1m[36mPage Load (0.6ms)[0m  [1m[34mSELECT "pages".* FROM "pages" WHERE "pages"."id" IN (19, 5, 15, 6, 7, 8, 14, 16, 20)[0m
